gamma_x  * x_ij * eta_ij^2 +
gamma_e  * e_ij *  eta_ij^2 +
gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
gamma_xe = 0.05
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
gamma_x  * x_ij * eta_ij^2 +
gamma_e  * e_ij * eta_ij^2 +
gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0
gamma_x = 0
gamma_e = 0.05
gamma_xe = 0.05
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0
gamma_x = 0.5
gamma_e = 0.05
gamma_xe = 0.05
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0
gamma_x = 0.5
gamma_e = 0.05
gamma_xe = 0.0
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0.4
gamma_x = 0.5
gamma_e = 0.05
gamma_xe = 0.0
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0.4
gamma_x = 0.5
gamma_e = 0.05
gamma_xe = 0.0
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0.4
gamma_x = 0.5
gamma_e = 0.05
gamma_xe = 0.0
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
N = 1e5
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0.4
gamma_x = 0.5
gamma_e = 0.05
gamma_xe = 0.0
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
N = 1e5
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0.4
gamma_x = 0.0
gamma_e = 0.05
gamma_xe = 0.0
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
N = 1e5
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0.4
gamma_x = 0.0
gamma_e = 0.05
gamma_xe = 0.0
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
N = 1e5
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0.4
gamma_x = 0.0
gamma_e = 0.05
gamma_xe = 0.0
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
#estimate selection
N = 1e5
beta = 0
beta_x = 0
beta_e = 0.0
beta_xe = 0
gamma = 0.1
gamma_x = 0.0
gamma_e = 0.1
gamma_xe = 0.0
x_ij = rnorm(N,0,sd_cue)
e_ij = rnorm(N,0,sd_noise)
sd_cue = 1
sd_noise = 1
Wbar = function(x){
mu_0 = 0
rho_1 = 0
sigma_0 = 0
eta_ij = (mu_0 + x[1]) + (rho_1 + x[2]) * x_ij + exp(sigma_0 + x[3]) * e_ij
W = 1 + beta *  eta_ij +
beta_x  * x_ij * eta_ij +
beta_e  * e_ij * eta_ij +
beta_xe * x_ij * e_ij * eta_ij +
0.5 * gamma    *  eta_ij^2 +
0.5 * gamma_x  * x_ij * eta_ij^2 +
0.5 * gamma_e  * e_ij * eta_ij^2 +
0.5 * gamma_xe * x_ij * e_ij * eta_ij^2
return(mean(W)) }
x = rep(0,3)
first.derivatives = grad(func = Wbar, x = x)
second.derivatives = hessian(func = Wbar, x = x)
denom = Wbar(x = x)
betas = first.derivatives/denom
gammas = second.derivatives/denom
round(betas,2)
round(gammas,2)
rstan:::rstudio_stanc("C:/Users/jormar/Dropbox/Tsimane studies/socioecological effects on fertility/nov2022 analysis/fertility prob model 16.stan")
rstan:::rstudio_stanc("C:/Users/jormar/Dropbox/Tsimane studies/socioecological effects on fertility/nov2022 analysis/fertility prob model 16.stan")
rstan:::rstudio_stanc("C:/Users/jormar/Dropbox/Tsimane studies/socioecological effects on fertility/nov2022 analysis/fertility prob model 16.stan")
install.packages(c("ade4", "ape", "BiocManager", "blavaan", "bookdown", "cachem", "classInt", "conquer", "data.table", "dbplyr", "dplyr", "dtplyr", "effectsize", "fastmap", "flextable", "forcats", "Formula", "fs", "future", "gargle", "gdtools", "geometry", "ggeffects", "ggplot2", "ggpubr", "ggrepel", "gh", "gmp", "haven", "Hmisc", "httpuv", "httr", "igraph", "insight", "kernlab", "lava", "lavaan", "lpSolve", "lubridate", "markdown", "multcomp", "mvnfast", "officer", "openxlsx", "packrat", "phytools", "posterior", "projpred", "raster", "RcppArmadillo", "RcppParallel", "RcppTOML", "RCurl", "readr", "readxl", "recipes", "reticulate", "rgeos", "RJSONIO", "Rmpfr", "RPostgreSQL", "RSQLite", "rstan", "rstatix", "simstudy", "sourcetools", "spData", "spdep", "terra", "tidybayes", "tidygraph", "tidyverse", "tinytex", "triebeard", "utf8", "xfun", "xts"))
install.packages(c("codetools", "MASS", "mgcv", "nlme", "survival"), lib="C:/Program Files/R/R-4.1.3/library")
setwd("C:/Users/jormar/Dropbox/Primates_IVSO project/Statistical methods and analyses/Github files/primate-SO-analysis")
#load packages
library(brms)
rstan::rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
library(mice)
library(ggplot2)
library(cowplot)
library(RColorBrewer)
#set path for cmdstan installation (optional)
cmdstanr::set_cmdstan_path("C:/Temp/cmdstan-2.29.2")
cmdstanr::set_cmdstan_path("C:/Stan/cmdstan-2.30.1")
#MCMC settings
n_iter <- 2000
n_warm <- 1000
n_chains <- 4
#load datasets
dataR = read.csv("dataR.csv")
dataG = read.csv("dataG.csv")
dataGR = read.csv("dataGR.csv")
#add redundant column for phylogenetic effects
dataR$phylo = dataR$Genus_species
dataG$phylo = dataG$Genus_species
dataGR$phylo = dataGR$Genus_species
#load phylogenies
#multiple to capture uncertainty
library(ape)
trees = read.nexus("vert phylo.nex")
#data files without uncertain zeroes for IVSO robustness checks
dRr = dataR[dataR$Nbr_social_units>1,]
dGr = dataG[dataG$Nbr_social_units>1,]
dGRr = dataGR[dataGR$Nbr_social_units>1,]
?cor
cor(dataGR$mean_Male_all, dataGR$mean_Female_all, use = "pairwise.complete.obs")
